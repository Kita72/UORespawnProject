@using Microsoft.JSInterop
@using Microsoft.Maui.Graphics
@using System.Text.Json
@using UORespawnApp.Scripts.Utilities
@using UORespawnApp.Scripts.Entities
@using UORespawnApp.Scripts.Services
@inject IJSRuntime JS
@inject ViewService ViewService
@inject ToastService ToastService
@implements IDisposable

<div class="container-fluid p-3">
    <div class="row">
        <div class="col-lg-9">
            <div class="alert alert-dark mb-2 d-flex justify-content-between align-items-center" style="width:800px;">
                <div>
                    <span class="bi bi-bounding-box me-1" style="color: goldenrod;"></span><strong style="color: goldenrod;">Box Spawn</strong> | @MapUtility.GetMapName(ViewService.CurrentMapId) | Size: @imageDim | Mouse: (@mouseWorldX, @mouseWorldY)
                </div>
                <div class="d-flex align-items-center gap-2">
                    <span class="bi bi-info-circle" style="color: #6c757d; cursor: help;" title="Draw spawn boxes on the map to define creature spawn areas. Use priority levels for overlapping regions."></span>
                    <span class="badge bg-light text-dark" title="Total spawns across all boxes">@GetTotalBoxSpawnCount() Spawns</span>
                    <button class="btn btn-sm @(zoomLevel == 2.0 ? "btn-primary" : "btn-outline-primary")" @onclick="ToggleZoom" title="Toggle Zoom (1x / 2x)">
                        <span class="bi bi-zoom-@(zoomLevel == 2.0 ? "in" : "out")"></span> @(zoomLevel == 1.0 ? "1x" : "2x")
                    </button>
                </div>
            </div>
            <div style="position:relative; overflow:hidden; width:800px; height:600px; background:#1a1a1a; border:1px solid #333;" 
                 tabindex="0" 
                 @onkeydown="OnKeyDown"
                 @onkeyup="OnKeyUp"
                 @onmouseenter="OnMapMouseEnter"
                 @ref="mapContainerRef">
                <img id="mapImg" src="@imageSrc" 
                     style="position:absolute; left:0; top:0; image-rendering:pixelated; transform-origin: top left; transform: scale(@(zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)));"
                     @onload="OnImageLoaded" />
                <canvas id="mapCanvas" width="800" height="600"
                        style="position:absolute; top:0; left:0; cursor:crosshair;"
                        @onmousedown="OnMouseDown"
                        @onmousemove="OnMouseMove"
                        @onmouseup="OnMouseUp"
                        @onmouseleave="OnMouseLeave"
                        @oncontextmenu:preventDefault />
            </div>
            <div class="card mt-2 shadow-sm" style="width:800px;">
                <div class="card-body py-2">
                    <small class="text-muted">
                        <strong>Controls:</strong> Left-Drag = Draw Spawn Box | Right-Drag = Pan Map | Arrow Keys/WASD = Pan Map
                    </small>
                </div>
            </div>
        </div>
        <div class="col-lg-3 right-column-container" style="padding-left:15px;">
            <!-- Mini Map Component -->
            <MiniMapComponent @ref="miniMapRef"
                              CanvasId="miniMapCanvas"
                              MainImageId="mapImg"
                              PanX="@panX"
                              PanY="@panY"
                              ZoomLevel="@zoomLevel"
                              OnMiniMapClick="HandleMiniMapClick"
                              OnResetView="ResetView" />

            <!-- Map Spawn List - Flex to fill remaining space -->
            <div class="card shadow-sm map-card spawn-list-container">
                <div class="card-header dark-header text-center spawn-list-header">
                    <span style="color: goldenrod;"><span class="bi bi-list-ul me-1"></span>Map Spawn</span>
                    <input type="number" 
                           class="spawn-search-input" 
                           value="@GetDisplayedSpawnId()" 
                           @oninput="HandleSpawnIdInput"
                           min="1" 
                           max="@GetSpawnCount()" 
                           placeholder="@(GetSpawnCount() == 0 ? "" : "ID")" 
                           title="Jump to spawn ID" />
                    <span style="color: goldenrod;">/ @GetSpawnCount()</span>
                </div>
                <div class="card-body p-2 spawn-list-body">
                    @if (GetSpawnList().Any())
                    {
                        @foreach (var spawn in GetSpawnList())
                        {
                            <div class="spawn-item @(selected == spawn ? "selected" : "")" @onclick="() => SelectSpawn(spawn)">
                                <div class="d-flex align-items-center justify-content-between">
                                    <div class="flex-grow-1">
                                        <div class="d-flex align-items-center gap-2">
                                            <strong>ID: @spawn.Position</strong>
                                            <span class="badge @GetPriorityBadgeClass(spawn.Priority)" title="Priority of Spawn Box Placed">P@(spawn.Priority)</span>
                                            @if (spawn.GetTotalSpawnCount() > 0)
                                            {
                                                <span class="badge bg-warning text-dark" title="Total spawns across all categories">@spawn.GetTotalSpawnCount() Total Spawns</span>
                                            }
                                        </div>
                                        @if (selected == spawn)
                                        {
                                            <small class="d-block text-muted mt-1">
                                                X:@spawn.SpawnBox.X Y:@spawn.SpawnBox.Y (@spawn.SpawnBox.Width x @spawn.SpawnBox.Height)
                                            </small>
                                        }
                                    </div>
                                    <button class="btn btn-danger btn-sm" @onclick="() => DeleteSpawn(spawn)" @onclick:stopPropagation="true" title="Delete">
                                        <span class="bi bi-trash"></span>
                                    </button>
                                </div>
                                @if (selected == spawn)
                                {
                                    <div class="spawn-controls">
                                        <!-- 6 Spawn Category Buttons - 2 rows of 3 -->
                                        <div class="row g-2 mb-2">
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(spawn, Frequency.Water)" @onclick:stopPropagation="true" title="Water (@((Settings.WaterChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-droplet-fill frequency-icon frequency-icon-water"></i>@spawn.WaterSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(spawn, Frequency.Weather)" @onclick:stopPropagation="true" title="Weather (@((Settings.WeatherChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-cloud-lightning-rain-fill frequency-icon frequency-icon-weather"></i>@spawn.WeatherSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(spawn, Frequency.Timed)" @onclick:stopPropagation="true" title="Timed (@((Settings.TimedChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-clock-fill frequency-icon frequency-icon-timed"></i>@spawn.TimedSpawns.Count
                                                </button>
                                            </div>
                                        </div>
                                        <div class="row g-2 mb-2">
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-secondary w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(spawn, Frequency.Common)" @onclick:stopPropagation="true" title="Common (@((Settings.CommonChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-people-fill frequency-icon frequency-icon-common"></i>@spawn.CommonSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-success w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(spawn, Frequency.UnCommon)" @onclick:stopPropagation="true" title="Uncommon (@((Settings.UnCommonChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-person-fill frequency-icon frequency-icon-uncommon"></i>@spawn.UncommonSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-danger w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(spawn, Frequency.Rare)" @onclick:stopPropagation="true" title="Rare (@((Settings.RareChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-star-fill frequency-icon frequency-icon-rare"></i>@spawn.RareSpawns.Count
                                                </button>
                                            </div>
                                        </div>

                                        <!-- Weather and Timed Dropdowns -->
                                        <div class="row g-2 mb-1">
                                            <div class="col-6">
                                                <label class="form-label mb-1 small text-center d-block">Weather Trigger</label>
                                                <select class="form-select form-select-sm" 
                                                        @bind="spawn.WeatherSpawn" 
                                                        @bind:after="() => SaveAfterTriggerChange(spawn)" 
                                                        @onclick:stopPropagation="true"
                                                        disabled="@(spawn.WeatherSpawns.Count == 0)">
                                                    @if (spawn.WeatherSpawns.Count == 0)
                                                    {
                                                        <option value="@WeatherTypes.None">None</option>
                                                    }
                                                    else
                                                    {
                                                        @foreach (var weather in Enum.GetValues<WeatherTypes>().Where(w => w != WeatherTypes.None))
                                                        {
                                                            <option value="@weather">@weather.ToString()</option>
                                                        }
                                                    }
                                                </select>
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label mb-1 small text-center d-block">Timed Trigger</label>
                                                <select class="form-select form-select-sm" 
                                                        @bind="spawn.TimedSpawn" 
                                                        @bind:after="() => SaveAfterTriggerChange(spawn)" 
                                                        @onclick:stopPropagation="true"
                                                        disabled="@(spawn.TimedSpawns.Count == 0)">
                                                    @if (spawn.TimedSpawns.Count == 0)
                                                    {
                                                        <option value="@TimeNames.None">None</option>
                                                    }
                                                    else
                                                    {
                                                        @foreach (var time in Enum.GetValues<TimeNames>().Where(t => t != TimeNames.None))
                                                        {
                                                            <option value="@time">@time.ToString().Replace("_", " ")</option>
                                                        }
                                                    }
                                                </select>
                                            </div>
                                        </div>
                                        @if (spawn.WeatherSpawns.Count == 0 || spawn.TimedSpawns.Count == 0)
                                        {
                                            <div class="row g-2 mb-2">
                                                <div class="col-12">
                                                    <small class="text-muted fst-italic">* Add Spawn to Open Triggers</small>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div class="alert alert-secondary mb-0">
                            <small>No spawn boxes created. Draw a box on the map to create one.</small>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Spawn Category Modal -->
<SpawnCategoryModal IsVisible="@showCategoryModal"
                    CategoryName="@currentCategory"
                    SpawnTypeName="Spawns"
                    SourceListName="Bestiary"
                    CurrentSpawns="@currentCategorySpawns"
                    SourceList="@(BestiaryListUtility.BestiaryNameList ?? new List<string>())"
                    OnClose="@CloseCategoryModal"
                    OnSave="@SaveCategoryModal" />

@code {
private string imageSrc = "";
private string imageDim = "Loading...";
private double panX = 0;
private double panY = 0;
private int mouseWorldX = 0;
private int mouseWorldY = 0;
private BoxSpawnEntity? selected = null;
private BoxSpawnEntity? hoveredSpawn = null;

private bool isDrawing = false;
private bool isPanning = false;

// Track mouse down position for click detection
private double mouseDownX = 0;
private double mouseDownY = 0;

private int imgWidth = 0;
private int imgHeight = 0;

private ElementReference mapContainerRef;

// Zoom level (1.0 = actual size, 2.0 = 2x zoomed in)
private double zoomLevel = 1.0;

// Store last position AND zoom for each map (static so it persists across component instances)
private static Dictionary<int, (double panX, double panY, double zoom)> mapPositions = new();

// Track which map we're currently viewing
private int currentMapTracked = 0; // Map0

// MiniMap component reference
private MiniMapComponent? miniMapRef;

// Category modal state
private bool showCategoryModal = false;
private string currentCategory = "Common";
private List<string> currentCategorySpawns = new();
private BoxSpawnEntity? editingSpawn = null;
private Frequency editingFrequency = Frequency.Common;

// Spawn search ID
private int? spawnSearchId = null;

    protected override void OnInitialized()
    {
        imageSrc = Utility.GetMapImagePath();

        // Fallback to default map if path is empty
        if (string.IsNullOrEmpty(imageSrc))
        {
            // If no map image available, leave empty - GetMapImagePath logs the error
            Logger.Warning("No map image available for current map");
        }

        // Track the initial map
        if (Utility.SESSION != null)
        {
            currentMapTracked = Utility.SESSION.Current_Map;
        }

        ViewService.OnMapChanged += HandleMapChanged;
    }

    private void HandleMapChanged()
    {
        // Save current position AND zoom for the OLD map (the one we're leaving)
        if (imgWidth > 0)
        {
            mapPositions[currentMapTracked] = (panX, panY, zoomLevel);
            Logger.Info($"Saved position and zoom for {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
        }
        
        // Update to track the NEW map
        if (Utility.SESSION != null)
        {
            currentMapTracked = Utility.SESSION.Current_Map;
            Logger.Info($"Switching to map: {currentMapTracked}");
        }
        
        // Restore position AND zoom for the NEW map IMMEDIATELY so rendering is correct from the start
        if (mapPositions.TryGetValue(currentMapTracked, out var savedPos))
        {
            panX = savedPos.panX;
            panY = savedPos.panY;
            zoomLevel = savedPos.zoom;
            Logger.Info($"Pre-loaded position and zoom for {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
        }
        else
        {
            panX = 0;
            panY = 0;
            zoomLevel = 1.0; // Default to 1x zoom for new maps
            Logger.Info($"New map {currentMapTracked}, defaulting to (0, 0) @ 1x zoom");
        }
        
        imageSrc = Utility.GetMapImagePath();
        selected = null;
        mouseWorldX = 0;
        mouseWorldY = 0;
        imgWidth = 0;
        imgHeight = 0;
        imageDim = "Loading...";
        spawnSearchId = null; // Reset spawn search when changing maps

        // Note: JavaScript will apply these values in OnImageLoaded after map loads

        StateHasChanged();
    }

    private async Task OnImageLoaded()
    {
        await Task.Delay(100);
        try
        {
            var result = await JS.InvokeAsync<string>("eval", @"
                (function() {
                    const img = document.getElementById('mapImg');
                    if (img && img.naturalWidth > 0) {
                        return img.naturalWidth + ',' + img.naturalHeight;
                    }
                    return '';
                })()
            ");
            
            if (!string.IsNullOrEmpty(result))
            {
                var parts = result.Split(',');
                if (int.TryParse(parts[0], out int w) && int.TryParse(parts[1], out int h))
                {
                    imgWidth = w;
                    imgHeight = h;
                    imageDim = $"{w}x{h}";
                    
                    // Restore saved position AND zoom for THIS map (currentMapTracked)
                    if (mapPositions.TryGetValue(currentMapTracked, out var savedPos))
                    {
                        panX = savedPos.panX;
                        panY = savedPos.panY;
                        zoomLevel = savedPos.zoom;
                        Logger.Info($"Restored position and zoom for {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
                    }
                    else
                    {
                        panX = 0;
                        panY = 0;
                        zoomLevel = 1.0; // Default to 1x zoom
                        Logger.Info($"First visit to {currentMapTracked}, starting at (0, 0) @ 1x");
                    }
                    
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.init({w}, {h})");

                    // Set the zoom level in JavaScript BEFORE any coordinate calculations
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.setZoomLevel({zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)})");

                    await SyncSettingsToJavaScript();

                    // Apply the restored (or reset) pan position BEFORE minimap init
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

                    // Initialize the mini map component AFTER pan is applied, passing current values
                    if (miniMapRef != null)
                    {
                        await miniMapRef.InitializeAsync(panX, panY, zoomLevel);
                    }

                    await Redraw();

                    // Re-apply XML spawners if toggle is ON
                    if (ViewService.ShowXMLSpawners)
                    {
                        var xmlSpawners = SpawnerListUtility.GetSpawnersForMap(ViewService.CurrentMapId);
                        if (xmlSpawners.Count > 0)
                        {
                            var options = new System.Text.Json.JsonSerializerOptions 
                            { 
                                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
                                WriteIndented = false 
                            };
                            var json = System.Text.Json.JsonSerializer.Serialize(xmlSpawners, options);
                            await JS.InvokeVoidAsync("eval", $"window.mapModule.showXMLSpawners({json})");
                            Logger.Info($"Re-applied XML spawners for {ViewService.CurrentMapId}: {xmlSpawners.Count} spawners");
                        }
                        await InvokeAsync(StateHasChanged); // Force UI update for button state
                    }

                    // Re-apply server spawns if toggle is ON
                    if (ViewService.ShowServerSpawns && MapDisplayUtility.HasSpawnData)
                    {
                        var spawnData = MapDisplayUtility.GetSpawnDataForMap(ViewService.CurrentMapId);
                        if (spawnData.Count > 0)
                        {
                            var options = new System.Text.Json.JsonSerializerOptions 
                            { 
                                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
                                WriteIndented = false 
                            };
                            var json = System.Text.Json.JsonSerializer.Serialize(spawnData, options);
                            await JS.InvokeVoidAsync("eval", $"window.mapModule.showServerSpawns({json})");
                            Logger.Info($"Re-applied server spawns for {ViewService.CurrentMapId}: {spawnData.Count} spawn points");
                        }
                        await InvokeAsync(StateHasChanged); // Force UI update for button state
                    }
                    
                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.Error("Image load error", ex);
            imageDim = "Error loading image";
        }
    }

    private async Task SyncSettingsToJavaScript()
    {
        try
        {
            // Get color as hex
            var color = Settings.BoxColor;
            var colorHex = $"#{(int)(color.Red * 255):X2}{(int)(color.Green * 255):X2}{(int)(color.Blue * 255):X2}";
            
            await JS.InvokeVoidAsync("eval", $@"
                window.mapModule.updateSettings('{colorHex}', {Settings.BoxLineSize}, {Settings.BoxColorInc});
            ");
            
            Logger.Info($"Settings synced to JavaScript: {colorHex}, {Settings.BoxLineSize}px, inc {Settings.BoxColorInc}");
        }
        catch (Exception ex)
        {
            Logger.Error("Settings sync error", ex);
        }
    }

    private async Task HandleMiniMapClick((double panX, double panY) newPosition)
    {
        panX = newPosition.panX;
        panY = newPosition.panY;

        // Save the new position for the current map (preserve zoom)
        mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

        // Update the mini map viewport
        if (miniMapRef != null)
        {
            await miniMapRef.UpdateViewport();
        }

        StateHasChanged();
        Logger.Info($"Mini-map click: pan to ({panX:F0}, {panY:F0})");
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        // Update mouse world coordinates
        await UpdateMouseCoordinates(e.OffsetX, e.OffsetY);

        // Track mouse down position for click detection
        mouseDownX = e.OffsetX;
        mouseDownY = e.OffsetY;

        if (e.Button == 0) // Left - draw
        {
            isDrawing = true;
            await JS.InvokeVoidAsync("eval", $"window.mapModule.startDrawing({e.OffsetX}, {e.OffsetY})");
        }
        else if (e.Button == 2) // Right - pan
        {
            isPanning = true;
            await JS.InvokeVoidAsync("eval", $"window.mapModule.startPanning({e.OffsetX}, {e.OffsetY})");
        }
    }
    
    private async Task OnMouseMove(MouseEventArgs e)
    {
        // Update mouse coordinates on every move
        await UpdateMouseCoordinates(e.OffsetX, e.OffsetY);

        if (isDrawing)
        {
            await JS.InvokeVoidAsync("eval", $"window.mapModule.updateDrawing({e.OffsetX}, {e.OffsetY})");
        }
        else if (isPanning)
        {
            await JS.InvokeVoidAsync("eval", $"window.mapModule.updatePanning({e.OffsetX}, {e.OffsetY})");

            // Get updated pan position and sync minimap (match Region/Vendor behavior)
            var panCoords = await JS.InvokeAsync<double[]>("eval", "window.mapModule.getPan()");
            if (panCoords.Length == 2)
            {
                panX = panCoords[0];
                panY = panCoords[1];
            }

            if (miniMapRef != null) await miniMapRef.UpdateViewport();
        }
        else
        {
            // Check for hover over spawn boxes when not drawing or panning
            await UpdateHoveredSpawn(e.OffsetX, e.OffsetY);

            // Update XML spawner hover (for dwell-based tooltip, like server spawns)
            if (ViewService.ShowXMLSpawners)
            {
                await JS.InvokeVoidAsync("eval", $"window.mapModule.updateXmlSpawnerHover({e.OffsetX}, {e.OffsetY})");
            }

            // Update server spawn hover (for dwell-based tooltip)
            if (ViewService.ShowServerSpawns)
            {
                await JS.InvokeVoidAsync("eval", $"window.mapModule.updateServerSpawnHover({e.OffsetX}, {e.OffsetY})");
            }
        }
    }
    
    private async Task UpdateMouseCoordinates(double screenX, double screenY)
    {
        try
        {
            var result = await JS.InvokeAsync<string>("eval", $"JSON.stringify(window.mapModule.screenToWorld({screenX}, {screenY}))");
            if (!string.IsNullOrEmpty(result))
            {
                var coords = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, int>>(result);
                if (coords != null)
                {
                    mouseWorldX = coords["x"];
                    mouseWorldY = coords["y"];
                    StateHasChanged();
                }
            }
        }
        catch { }
    }
    
    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (isDrawing && Utility.SESSION != null)
        {
            isDrawing = false;
            var rect = await JS.InvokeAsync<RectData>("eval", "window.mapModule.finishDrawing()");

            if (rect != null && rect.Width > 0 && rect.Height > 0)
            {
                // Safely get the current spawn list for this map
                var currentSpawnList = GetSpawnList();

                var spawn = new BoxSpawnEntity
                {
                    Position = currentSpawnList.Count + 1,
                    MapId = Utility.SESSION.Current_Map,
                    SpawnBox = new Rect(rect.X, rect.Y, rect.Width, rect.Height),
                    WeatherSpawn = WeatherTypes.None,
                    TimedSpawn = TimeNames.None,
                    WaterSpawns = new(),
                    WeatherSpawns = new(),
                    TimedSpawns = new(),
                    CommonSpawns = new(),
                    UncommonSpawns = new(),
                    RareSpawns = new()
                };

                Utility.AddBoxSpawn(Utility.SESSION.Current_Map, spawn);

                // Calculate priority based on containment
                CalculateSpawnPriority(spawn);

                selected = spawn;
                spawnSearchId = spawn.Position; // Sync the search ID to the newly created spawn

                Logger.Info($"Spawn #{spawn.Position} created at ({spawn.SpawnBox.X},{spawn.SpawnBox.Y}) size {spawn.SpawnBox.Width}x{spawn.SpawnBox.Height} Priority:{spawn.Priority}");

                // Auto-save spawn data
                Utility.SaveSpawnData();
                Logger.Info("Auto-saved spawn data");

                // Force a complete redraw
                await Redraw();
                StateHasChanged();

                // Auto-scroll to the newly created spawn in the list
                await Task.Delay(100); // Small delay to ensure DOM is updated
                await ScrollToSelectedSpawn();
            }
            else
            {
                // Check if this was a click (not a drag) - detect spawn box click
                double deltaX = Math.Abs(e.OffsetX - mouseDownX);
                double deltaY = Math.Abs(e.OffsetY - mouseDownY);

                // If mouse moved less than 5 pixels, treat as a click
                if (deltaX < 5 && deltaY < 5)
                {
                    await TrySelectSpawnAtPosition(e.OffsetX, e.OffsetY);
                }
                else
                {
                    Logger.Info("Box too small or invalid");
                }
            }
        }
        else if (isPanning)
        {
            isPanning = false;
            var pan = await JS.InvokeAsync<PanData>("eval", "window.mapModule.finishPanning()");
            if (pan != null)
            {
                panX = pan.X;
                panY = pan.Y;

                // Save the new position for the current map immediately (preserve zoom)
                mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

                if (miniMapRef != null) await miniMapRef.UpdateViewport();
                StateHasChanged();
            }
        }
    }
    
    private async Task OnMouseLeave()
    {
        isDrawing = false;
        isPanning = false;

        // Clear hover highlight when mouse leaves canvas
        if (hoveredSpawn != null)
        {
            hoveredSpawn = null;
            await JS.InvokeVoidAsync("eval", "window.mapModule.setHoveredSpawn(null)");
        }

        // Clear XML spawner hover when mouse leaves
        if (ViewService.ShowXMLSpawners)
        {
            await JS.InvokeVoidAsync("eval", "window.mapModule.clearXmlSpawnerHover()");
        }

        // Clear server spawn hover when mouse leaves
        if (ViewService.ShowServerSpawns)
        {
            await JS.InvokeVoidAsync("eval", "window.mapModule.clearServerSpawnHover()");
        }
    }
    
    private async Task ResetView()
    {
        panX = 0;
        panY = 0;
        zoomLevel = 1.0; // Reset to default 1x zoom

        // Clear the saved position for the CURRENT map
        mapPositions.Remove(currentMapTracked);
        Logger.Info($"Reset position and zoom for {currentMapTracked} to (0, 0) @ 1x");

        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");
        if (miniMapRef != null) await miniMapRef.UpdateViewport();
        StateHasChanged();
    }
    
    private async Task ToggleZoom()
    {
        // Calculate the current center of the viewport in world coordinates
        // This is what we want to keep centered after zoom changes
        double centerWorldX = (-panX / zoomLevel) + (800.0 / 2.0 / zoomLevel);
        double centerWorldY = (-panY / zoomLevel) + (600.0 / 2.0 / zoomLevel);
        
        Logger.Info($"Current center before zoom: world ({centerWorldX:F0}, {centerWorldY:F0}) at {zoomLevel}x");
        
        // Toggle between 1x (actual size) and 2x (zoomed in)
        double oldZoom = zoomLevel;
        zoomLevel = zoomLevel == 2.0 ? 1.0 : 2.0;
        
        // Recalculate pan to keep the same world position centered
        // Formula: panX = -(centerWorldX * newZoom) + (viewport_width / 2)
        panX = -(centerWorldX * zoomLevel) + 400; // 800/2
        panY = -(centerWorldY * zoomLevel) + 300; // 600/2
        
        Logger.Info($"New center after zoom: world ({centerWorldX:F0}, {centerWorldY:F0}) at {zoomLevel}x, pan=({panX:F0}, {panY:F0})");
        
        // Update JavaScript zoom level immediately
        await JS.InvokeVoidAsync("eval", $"window.mapModule.setZoomLevel({zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)})");

        // Apply the new pan position
        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

        // Save the new zoom level and position for current map
        mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

        // Redraw everything to ensure boxes are correctly positioned
        await Redraw();

        // Update mini-map viewport with new zoom
        if (miniMapRef != null) await miniMapRef.UpdateViewport();

        StateHasChanged();
    }
    
    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        // Check if it's a panning key (WASD or arrows)
        var key = e.Key.ToLower();
        if (key == "w" || key == "a" || key == "s" || key == "d" ||
            key == "arrowup" || key == "arrowdown" || key == "arrowleft" || key == "arrowright")
        {
            // Add key to active set and start smooth animation
            await JS.InvokeVoidAsync("eval", $"window.mapModule.addKey('{key}')");

            // Start tracking pan position for minimap updates
            await StartKeyPanTracking();
        }
    }

    private async Task OnKeyUp(KeyboardEventArgs e)
    {
        // Remove key from active set
        var key = e.Key.ToLower();
        await JS.InvokeVoidAsync("eval", $"window.mapModule.removeKey('{key}')");

        // Check if all keys are released
        var keysCount = await JS.InvokeAsync<int>("eval", "window.mapModule.keyStates.size");
        if (keysCount == 0)
        {
            // Stop tracking when all keys released
            StopKeyPanTracking();
        }

        // Sync pan position from JavaScript back to C#
        try
        {
            var result = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.mapModule.getPanPosition())");
            if (!string.IsNullOrEmpty(result))
            {
                var pos = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, double>>(result);
                if (pos != null)
                {
                    panX = pos["x"];
                    panY = pos["y"];

                    // Save the new position for the current map (preserve zoom)
                    mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

                    if (miniMapRef != null) await miniMapRef.UpdateViewport();
                    StateHasChanged();
                }
            }
        }
        catch { }
    }
    
    private async Task OnMapMouseEnter()
    {
        // Auto-focus the map container when mouse enters so keyboard controls work immediately
        try
        {
            await JS.InvokeVoidAsync("eval", @"
                (function() {
                    const container = document.querySelector('[tabindex=""0""]');
                    if (container) container.focus();
                })()
            ");
        }
        catch { }
    }

    private int GetXMLSpawnerCount()
    {
        return SpawnerListUtility.GetSpawnersForMap(ViewService.CurrentMapId).Count;
    }

    private int GetServerSpawnCount()
    {
        if (!MapDisplayUtility.HasSpawnData)
        {
            return 0;
        }
        return MapDisplayUtility.GetSpawnDataCount(ViewService.CurrentMapId);
    }

    private async Task Redraw()
    {
        try
        {
            if (Utility.SESSION != null)
            {
                var spawns = Utility.BoxSpawns[Utility.SESSION.Current_Map];
                Logger.Info($"Redrawing {spawns.Count} spawns for {Utility.SESSION.Current_Map}");

                // Serialize with proper options
                var options = new JsonSerializerOptions 
                { 
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                    WriteIndented = false 
                };
                var json = System.Text.Json.JsonSerializer.Serialize(spawns, options);
                
                await JS.InvokeVoidAsync("eval", $"window.mapModule.redraw({json})");
                
                Logger.Info("Redraw complete");
            }
        }
        catch (Exception ex)
        {
            Logger.Error("Redraw error", ex);
        }
    }

    private List<BoxSpawnEntity> GetSpawnList()
    {
        if (Utility.SESSION == null) return new List<BoxSpawnEntity>();

        // Safely get spawn list with null check for dictionary key
        if (!Utility.BoxSpawns.TryGetValue(Utility.SESSION.Current_Map, out var spawnList))
        {
            return new List<BoxSpawnEntity>();
        }
        
        // If search ID is set and valid, reorder list to start from that ID
        if (spawnSearchId.HasValue && spawnSearchId.Value > 0)
        {
            var searchId = spawnSearchId.Value;
            
            // Split list: spawns from searchId onwards, then spawns before searchId (wrap around)
            var fromId = spawnList.Where(s => s.Position >= searchId).OrderBy(s => s.Position);
            var beforeId = spawnList.Where(s => s.Position < searchId).OrderBy(s => s.Position);
            
            return fromId.Concat(beforeId).ToList();
        }
        
        // Default: return in Position order
        return spawnList.OrderBy(s => s.Position).ToList();
    }
    
    private int? GetDisplayedSpawnId()
    {
        // If no spawns exist, show 0
        if (GetSpawnCount() == 0)
        {
            return 0;
        }

        // If user is typing (spawnSearchId has manual value different from selected), show that
        // Otherwise show the selected spawn's Position, or null if nothing selected
        if (spawnSearchId.HasValue)
        {
            return spawnSearchId;
        }
        return selected?.Position;
    }

    private async Task HandleSpawnIdInput(ChangeEventArgs e)
    {
        int maxCount = GetSpawnCount();

        // If no spawns exist, ignore input and keep at 0
        if (maxCount == 0)
        {
            spawnSearchId = null;
            return;
        }

        // Parse the input value
        if (int.TryParse(e.Value?.ToString(), out int value))
        {
            spawnSearchId = value;
        }
        else
        {
            spawnSearchId = null;
        }

        // Validate and auto-jump
        if (spawnSearchId.HasValue)
        {
            // Clamp value to valid range
            if (spawnSearchId.Value > maxCount)
            {
                spawnSearchId = maxCount;
                Logger.Info($"Search ID clamped to max: {maxCount}");
            }
            else if (spawnSearchId.Value < 1)
            {
                spawnSearchId = 1;
                Logger.Info("Search ID clamped to min: 1");
            }

            // Auto-jump to the spawn
            if (Utility.SESSION != null)
            {
                var spawns = Utility.BoxSpawns[Utility.SESSION.Current_Map];
                var targetSpawn = spawns.FirstOrDefault(s => s.Position == spawnSearchId.Value);

                if (targetSpawn != null)
                {
                    selected = targetSpawn;
                    await JumpToSpawn(targetSpawn);
                    Logger.Info($"Quick search: jumped to Spawn #{targetSpawn.Position}");
                }
            }
        }
    }

    private int GetSpawnCount()
    {
        return GetSpawnList().Count;
    }
    
    private void CalculateSpawnPriority(BoxSpawnEntity spawn)
    {
        // This method is now deprecated - use RecalculateAllPriorities instead
        // Keeping for backwards compatibility but it just triggers a full recalc
        RecalculateAllPriorities();
    }

    private bool IsCompletelyContained(Rect inner, Rect outer)
    {
        // Check if inner is completely inside outer (not equal)
        return inner.Left >= outer.Left &&
               inner.Right <= outer.Right &&
               inner.Top >= outer.Top &&
               inner.Bottom <= outer.Bottom &&
               !(inner.Left == outer.Left && inner.Right == outer.Right && 
                 inner.Top == outer.Top && inner.Bottom == outer.Bottom);
    }

    private bool BoxesIntersect(Rect box1, Rect box2)
    {
        return !(box1.Right < box2.Left || box1.Left > box2.Right ||
                 box1.Bottom < box2.Top || box1.Top > box2.Bottom);
    }

    private double GetIntersectionArea(Rect box1, Rect box2)
    {
        // Calculate the intersection area between two boxes
        double left = Math.Max(box1.Left, box2.Left);
        double right = Math.Min(box1.Right, box2.Right);
        double top = Math.Max(box1.Top, box2.Top);
        double bottom = Math.Min(box1.Bottom, box2.Bottom);

        if (left < right && top < bottom)
        {
            return (right - left) * (bottom - top);
        }
        return 0;
    }
    
    private string GetPriorityBadgeClass(int priority)
    {
        return priority switch
        {
            0 => "bg-secondary",
            1 => "bg-primary",
            2 => "bg-info",
            3 => "bg-warning",
            _ => "bg-danger"
        };
    }

    private async Task TrySelectSpawnAtPosition(double screenX, double screenY)
    {
        try
        {
            // Convert screen coordinates to world coordinates using JS
            var result = await JS.InvokeAsync<string>("eval", $"JSON.stringify(window.mapModule.screenToWorld({screenX}, {screenY}))");
            if (string.IsNullOrEmpty(result)) return;

            var coords = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, int>>(result);
            if (coords == null) return;

            int worldX = coords["x"];
            int worldY = coords["y"];

            // Check for XML spawner click first (if XML spawners are visible) - XML spawners always have highest click priority
            if (ViewService.ShowXMLSpawners)
            {
                var xmlIdx = await JS.InvokeAsync<int>("eval", $"window.mapModule.findXmlSpawnerAt({worldX}, {worldY})");
                if (xmlIdx >= 0)
                {
                    // Toggle XML spawner selection - pass screen coordinates for tooltip
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.handleXmlSpawnerClick({xmlIdx}, {screenX}, {screenY})");
                    return; // Don't select spawn boxes when clicking XML spawners
                }
                else
                {
                    // Clicked outside XML spawner - clear selection
                    await JS.InvokeVoidAsync("eval", "window.mapModule.clearXmlSpawnerSelection()");
                }
            }

            // Find spawn box that contains this point
            // Prioritize smaller/higher-priority boxes (more specific spawns)
            var spawns = GetSpawnList();
            BoxSpawnEntity? clickedSpawn = null;
            double smallestArea = double.MaxValue;

            foreach (var spawn in spawns)
            {
                var box = spawn.SpawnBox;

                // Check if point is inside this box
                if (worldX >= box.X && worldX <= box.X + box.Width &&
                    worldY >= box.Y && worldY <= box.Y + box.Height)
                {
                    double area = box.Width * box.Height;

                    // Prefer smaller boxes (more specific) or higher priority
                    if (clickedSpawn == null || area < smallestArea || 
                        (area == smallestArea && spawn.Priority > clickedSpawn.Priority))
                    {
                        clickedSpawn = spawn;
                        smallestArea = area;
                    }
                }
            }

            if (clickedSpawn != null)
            {
                Logger.Info($"Clicked on Spawn #{clickedSpawn.Position} at world ({worldX}, {worldY})");

                // Select the spawn
                selected = clickedSpawn;
                spawnSearchId = clickedSpawn.Position;

                // Redraw to show selection
                await Redraw();
                StateHasChanged();

                // Scroll to the selected spawn in the list
                await Task.Delay(50);
                await ScrollToSelectedSpawn();
            }
        }
        catch (Exception ex)
        {
            Logger.Error("Error selecting spawn at position", ex);
        }
    }

    private async Task UpdateHoveredSpawn(double screenX, double screenY)
    {
        try
        {
            // Convert screen coordinates to world coordinates
            var result = await JS.InvokeAsync<string>("eval", $"JSON.stringify(window.mapModule.screenToWorld({screenX}, {screenY}))");
            if (string.IsNullOrEmpty(result)) return;

            var coords = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, int>>(result);
            if (coords == null) return;

            int worldX = coords["x"];
            int worldY = coords["y"];

            // Find spawn box that contains this point - prefer highest priority (smallest/most specific)
            var spawns = GetSpawnList();
            BoxSpawnEntity? newHoveredSpawn = null;
            int highestPriority = -1;
            double smallestArea = double.MaxValue;

            foreach (var spawn in spawns)
            {
                var box = spawn.SpawnBox;

                // Check if point is inside this box
                if (worldX >= box.X && worldX <= box.X + box.Width &&
                    worldY >= box.Y && worldY <= box.Y + box.Height)
                {
                    double area = box.Width * box.Height;

                    // Prefer highest priority, then smallest area
                    if (spawn.Priority > highestPriority || 
                        (spawn.Priority == highestPriority && area < smallestArea))
                    {
                        newHoveredSpawn = spawn;
                        highestPriority = spawn.Priority;
                        smallestArea = area;
                    }
                }
            }

            // Only update if hover changed
            if (newHoveredSpawn != hoveredSpawn)
            {
                hoveredSpawn = newHoveredSpawn;

                // Update JavaScript with hovered spawn ID for highlighting
                if (hoveredSpawn != null)
                {
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.setHoveredSpawn({hoveredSpawn.Position})");
                }
                else
                {
                    await JS.InvokeVoidAsync("eval", "window.mapModule.setHoveredSpawn(null)");
                }
            }
        }
        catch { }
    }

    private async Task SelectSpawn(BoxSpawnEntity spawn)
    {
        selected = spawn;

        // Sync the search ID to show the selected spawn's position
        spawnSearchId = spawn.Position;

        // Jump to spawn location on map
        await JumpToSpawn(spawn);

        StateHasChanged();
    }
    
    private async Task JumpToSpawn(BoxSpawnEntity spawn)
    {
        // Calculate the center of the spawn box
        double centerX = spawn.SpawnBox.X + (spawn.SpawnBox.Width / 2.0);
        double centerY = spawn.SpawnBox.Y + (spawn.SpawnBox.Height / 2.0);
        
        
        // Center the viewport on this position
        // Account for current zoom level and viewport size
        double newPanX = -(centerX * zoomLevel) + 400; // Center horizontally (800/2)
        double newPanY = -(centerY * zoomLevel) + 300; // Center vertically (600/2)

        panX = newPanX;
        panY = newPanY;

        // Save the new position for the current map (preserve zoom)
        mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");
        if (miniMapRef != null) await miniMapRef.UpdateViewport();

        Logger.Info($"Jumped to Spawn #{spawn.Position} at ({centerX:F0}, {centerY:F0})");
    }
    
    private async Task DeleteSpawn(BoxSpawnEntity spawn)
    {
        if (Utility.SESSION == null) return;
        
        var spawns = Utility.BoxSpawns[Utility.SESSION.Current_Map];
        spawns.Remove(spawn);
        
        // Reindex positions (IDs)
        for (int i = 0; i < spawns.Count; i++)
        {
            spawns[i].Position = i + 1;
        }
        
        // Recalculate priorities for all remaining spawns
        RecalculateAllPriorities();
        
        // Clear selection if deleted spawn was selected
        if (selected == spawn)
        {
            selected = null;
            spawnSearchId = null; // Clear the search ID too
        }

        // Auto-save spawn data
        Utility.SaveSpawnData();
        Logger.Info("Auto-saved after delete");
        
        await Redraw();
        StateHasChanged();
    }
    
    private void RecalculateAllPriorities()
    {
        var spawns = GetSpawnList();
        if (spawns.Count == 0) return;

        // Reset all priorities first
        foreach (var spawn in spawns)
        {
            spawn.Priority = 0;
        }

        // Build containment relationships
        // For each box, find all boxes that completely contain it
        var containedBy = new Dictionary<BoxSpawnEntity, List<BoxSpawnEntity>>();
        foreach (var spawn in spawns)
        {
            containedBy[spawn] = new List<BoxSpawnEntity>();

            foreach (var other in spawns)
            {
                if (other == spawn) continue;

                // Check if 'spawn' is completely contained by 'other'
                if (IsCompletelyContained(spawn.SpawnBox, other.SpawnBox))
                {
                    containedBy[spawn].Add(other);
                }
            }
        }

        // Calculate priority based on containment depth
        // Priority = number of boxes that contain this box
        foreach (var spawn in spawns)
        {
            spawn.Priority = containedBy[spawn].Count;
        }

        // Handle partial overlaps: if a box doesn't have a clear containment relationship
        // but overlaps with other boxes, inherit priority from the box with most shared area
        foreach (var spawn in spawns)
        {
            // Only check boxes with priority 0 that might be overlapping others
            if (spawn.Priority > 0) continue;

            double maxSharedArea = 0;
            int inheritedPriority = 0;

            foreach (var other in spawns)
            {
                if (other == spawn) continue;
                if (!BoxesIntersect(spawn.SpawnBox, other.SpawnBox)) continue;

                // Skip if this is a containment relationship (already handled)
                if (IsCompletelyContained(spawn.SpawnBox, other.SpawnBox)) continue;
                if (IsCompletelyContained(other.SpawnBox, spawn.SpawnBox)) continue;

                // Calculate shared area for partial overlaps
                double sharedArea = GetIntersectionArea(spawn.SpawnBox, other.SpawnBox);
                if (sharedArea > maxSharedArea)
                {
                    maxSharedArea = sharedArea;
                    inheritedPriority = other.Priority;
                }
            }

            // If we found a significant overlap, inherit that priority
            if (maxSharedArea > 0)
            {
                spawn.Priority = inheritedPriority;
            }
        }

        // Log the results
        foreach (var spawn in spawns)
        {
            Logger.Info($"Spawn #{spawn.Position} Priority: {spawn.Priority}");
        }
    }
    
    // Public method to refresh settings when changed in Settings page
    public async Task RefreshMapSettings()
    {
        await SyncSettingsToJavaScript();
    }
    
    private async Task ScrollToSelectedSpawn()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", @"
                (function() {
                    const selected = document.querySelector('.spawn-item.selected');
                    if (selected) {
                        selected.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                })()
            ");
        }
        catch (Exception ex)
        {
            Logger.Error("Scroll to spawn error", ex);
        }
    }
    
    private void SaveAfterTriggerChange(BoxSpawnEntity spawn)
    {
        Utility.SaveSpawnData();
        StateHasChanged();
        Logger.Info($"Auto-saved after trigger change for Spawn #{spawn.Position}");
    }
    
    private void OpenCategoryModal(BoxSpawnEntity spawn, Frequency frequency)
    {
        editingSpawn = spawn;
        editingFrequency = frequency;

        // IMPORTANT: Create a NEW copy of the list to avoid reference issues
        var sourceList = frequency switch
        {
            Frequency.Water => spawn.WaterSpawns,
            Frequency.Weather => spawn.WeatherSpawns,
            Frequency.Timed => spawn.TimedSpawns,
            Frequency.Common => spawn.CommonSpawns,
            Frequency.UnCommon => spawn.UncommonSpawns,
            Frequency.Rare => spawn.RareSpawns,
            _ => new List<string>()
        };

        // Create a brand new list with copies of the strings
        currentCategorySpawns = new List<string>(sourceList);

        currentCategory = frequency.ToString();
        showCategoryModal = true;
        StateHasChanged();

        Logger.Info($"Opened {frequency} modal for Spawn #{spawn.Position} with {currentCategorySpawns.Count} creatures");
    }
    
    private void CloseCategoryModal()
    {
        showCategoryModal = false;
        editingSpawn = null;
        StateHasChanged();
    }
    
    private void SaveCategoryModal()
    {
        if (editingSpawn != null)
        {
            // Clear the target list and copy from the modal list
            var targetList = editingFrequency switch
            {
                Frequency.Water => editingSpawn.WaterSpawns,
                Frequency.Weather => editingSpawn.WeatherSpawns,
                Frequency.Timed => editingSpawn.TimedSpawns,
                Frequency.Common => editingSpawn.CommonSpawns,
                Frequency.UnCommon => editingSpawn.UncommonSpawns,
                Frequency.Rare => editingSpawn.RareSpawns,
                _ => null
            };

            if (targetList != null)
            {
                targetList.Clear();

                // Only add non-empty names
                foreach (var name in currentCategorySpawns)
                {
                    if (!string.IsNullOrWhiteSpace(name))
                    {
                        targetList.Add(name);
                    }
                    else
                    {
                        Logger.Warning($"Skipped empty creature name in {currentCategory} for Spawn #{editingSpawn.Position}");
                    }
                }

                Logger.Info($"Saved {targetList.Count} {currentCategory} spawns for Spawn #{editingSpawn.Position}");

                // Auto-set trigger logic
                if (editingFrequency == Frequency.Weather)
                {
                    // If first weather spawn added (was 0, now > 0) and trigger is None, auto-set to Rain
                    if (targetList.Count > 0 && editingSpawn.WeatherSpawn == WeatherTypes.None)
                    {
                        editingSpawn.WeatherSpawn = WeatherTypes.Rain; // First non-None enum
                        Logger.Info($"Auto-set Weather Trigger to Rain for Spawn #{editingSpawn.Position}");
                    }
                    // If last weather spawn removed (now 0), auto-reset to None
                    else if (targetList.Count == 0 && editingSpawn.WeatherSpawn != WeatherTypes.None)
                    {
                        editingSpawn.WeatherSpawn = WeatherTypes.None;
                        Logger.Info($"Auto-reset Weather Trigger to None for Spawn #{editingSpawn.Position}");
                    }
                }
                else if (editingFrequency == Frequency.Timed)
                {
                    // If first timed spawn added (was 0, now > 0) and trigger is None, auto-set to Witching_Hour
                    if (targetList.Count > 0 && editingSpawn.TimedSpawn == TimeNames.None)
                    {
                        editingSpawn.TimedSpawn = TimeNames.Witching_Hour; // First non-None enum
                        Logger.Info($"Auto-set Time Trigger to Witching_Hour for Spawn #{editingSpawn.Position}");
                    }
                    // If last timed spawn removed (now 0), auto-reset to None
                    else if (targetList.Count == 0 && editingSpawn.TimedSpawn != TimeNames.None)
                    {
                        editingSpawn.TimedSpawn = TimeNames.None;
                        Logger.Info($"Auto-reset Time Trigger to None for Spawn #{editingSpawn.Position}");
                    }
                }
            }
            else
            {
                Logger.Warning($"{currentCategory} spawn list not yet supported in legacy BoxSpawnEntity - upgrade to BoxSpawnEntity coming soon!");
            }

            // Save the data
            Utility.SaveSpawnData();
        }

        StateHasChanged();
    }
    
    private int GetTotalBoxSpawnCount()
    {
        if (Utility.SESSION == null) return 0;

        if (!Utility.BoxSpawns.TryGetValue(Utility.SESSION.Current_Map, out var spawnList))
        {
            return 0;
        }

        return spawnList.Sum(s => s.GetTotalSpawnCount());
    }

    // Key panning state tracking
    private bool isKeyPanning = false;
    private System.Threading.Timer? keyPanTimer;

    private async Task StartKeyPanTracking()
    {
        if (isKeyPanning) return;
        isKeyPanning = true;

        // Start a timer that syncs pan position while keys are held
        keyPanTimer = new System.Threading.Timer(async _ =>
        {
            if (!isKeyPanning) return;

            try
            {
                await InvokeAsync(async () =>
                {
                    var result = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.mapModule.getPanPosition())");
                    if (!string.IsNullOrEmpty(result))
                    {
                        var pos = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, double>>(result);
                        if (pos != null)
                        {
                            panX = pos["x"];
                            panY = pos["y"];
                            if (miniMapRef != null) await miniMapRef.UpdateViewport();
                            StateHasChanged();
                        }
                    }
                });
            }
            catch { }
        }, null, 0, 50); // Update every 50ms (~20fps)
    }

    private void StopKeyPanTracking()
    {
        isKeyPanning = false;
        keyPanTimer?.Dispose();
        keyPanTimer = null;
    }

    public void Dispose()
    {
        ViewService.OnMapChanged -= HandleMapChanged;
        keyPanTimer?.Dispose();

        // Auto-save settings when leaving the page (binary file for server)
        try
        {
            Utility.SaveSettings();
            Logger.Info("Auto-saved settings on page leave");
        }
        catch (Exception ex)
        {
            Logger.Error("Error auto-saving settings", ex);
        }
    }
}
