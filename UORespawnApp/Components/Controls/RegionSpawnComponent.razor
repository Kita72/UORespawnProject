@using Microsoft.JSInterop
@using Microsoft.Maui.Graphics
@using System.Text.Json
@using UORespawnApp.Scripts.Constants
@using UORespawnApp.Scripts.Utilities
@using UORespawnApp.Scripts.Entities
@using UORespawnApp.Scripts.Services
@inject IJSRuntime JS
@inject ViewService ViewService
@inject ToastService ToastService
@implements IDisposable

<div class="container-fluid p-3">
    <div class="row">
        <div class="col-lg-9">
            <div class="alert alert-dark mb-2 d-flex justify-content-between align-items-center" style="width:800px;">
                <div>
                    <span class="bi bi-map me-1" style="color: goldenrod;"></span><strong style="color: goldenrod;">Region Spawn</strong> | @MapUtility.GetMapName(ViewService.CurrentMapId) | Size: @imageDim | Mouse: (@mouseWorldX, @mouseWorldY)
                </div>
                <div class="d-flex align-items-center gap-2">
                    <span class="bi bi-info-circle" style="color: #6c757d; cursor: help;" title="Configure spawns for named server regions. Click a region on the map or list to edit its spawn configuration."></span>
                    <span class="badge bg-light text-dark" title="Total spawns across all regions">@GetTotalRegionSpawnCount() Spawns</span>
                    <button class="btn btn-sm @(zoomLevel == 2.0 ? "btn-primary" : "btn-outline-primary")" @onclick="ToggleZoom" title="Toggle Zoom (1x / 2x)">
                        <span class="bi bi-zoom-@(zoomLevel == 2.0 ? "in" : "out")"></span> @(zoomLevel == 1.0 ? "1x" : "2x")
                    </button>
                </div>
            </div>
            <div style="position:relative; overflow:hidden; width:800px; height:600px; background:#1a1a1a; border:1px solid #333;" 
                 tabindex="0" 
                 @onkeydown="OnKeyDown"
                 @onkeyup="OnKeyUp"
                 @onmouseenter="OnMapMouseEnter"
                 @ref="mapContainerRef">
                <img id="regionMapImg" src="@imageSrc" 
                     style="position:absolute; left:0; top:0; image-rendering:pixelated; transform-origin: top left; transform: scale(@(zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)));"
                     @onload="OnImageLoaded" />
                <canvas id="regionMapCanvas" width="800" height="600"
                        style="position:absolute; top:0; left:0; cursor:pointer;"
                        @onmousedown="OnMouseDown"
                        @onmousemove="OnMouseMove"
                        @onmouseup="OnMouseUp"
                        @onmouseleave="OnMouseLeave"
                        @oncontextmenu:preventDefault />
            </div>
            <div class="card mt-2 shadow-sm" style="width:800px;">
                <div class="card-body py-2">
                    <small class="text-muted">
                        <strong>Controls:</strong> Left-Click Region = Select | Right-Drag = Pan Map | Arrow Keys/WASD = Pan Map
                    </small>
                </div>
            </div>
        </div>
        <div class="col-lg-3 right-column-container" style="padding-left:15px;">
            <!-- Mini Map Component -->
            <MiniMapComponent @ref="miniMapRef"
                              CanvasId="regionMiniMapCanvas"
                              MainImageId="regionMapImg"
                              PanX="@panX"
                              PanY="@panY"
                              ZoomLevel="@zoomLevel"
                              OnMiniMapClick="HandleMiniMapClick"
                              OnResetView="ResetView" />
            
            <!-- Region Spawn List - Flex to fill remaining space -->
            <div class="card shadow-sm map-card spawn-list-container">
                <div class="card-header dark-header text-center spawn-list-header">
                    <span style="color: goldenrod;"><span class="bi bi-geo-alt me-1"></span>Regions</span>
                    <input type="number" 
                           class="spawn-search-input" 
                           value="@GetDisplayedRegionIndex()" 
                           @oninput="HandleRegionIndexInput"
                           min="1" 
                           max="@GetRegionCount()" 
                           placeholder="@(GetRegionCount() == 0 ? "" : "#")" 
                           title="Jump to region by list position" />
                    <span style="color: goldenrod;">/ @GetRegionCount()</span>
                </div>
                <div class="card-body p-2 spawn-list-body">
                    @{
                        var regions = GetRegionsForCurrentMap();
                        var sortedRegions = regions.OrderBy(r => r.Name).ToList();
                        var cardIndex = 0;
                    }
                    @if (sortedRegions.Any())
                    {
                        @foreach (var region in sortedRegions)
                        {
                            cardIndex++;
                            var entity = GetRegionEntity(region.Name);
                            var isSelected = selectedRegion != null && selectedRegion.Name == region.Name;

                            <div class="spawn-item @(isSelected ? "selected" : "")" @onclick="() => SelectRegion(region)">
                                <div class="d-flex align-items-center justify-content-between">
                                    <div class="flex-grow-1 d-flex align-items-center">
                                        <span class="card-index me-2">@cardIndex</span>
                                        <strong title="@region.Name">@(isSelected ? region.Name : FormatRegionName(region.Name))</strong>
                                    </div>
                                    <div class="d-flex align-items-center gap-2">
                                        @if (entity != null && entity.GetTotalSpawnCount() > 0)
                                        {
                                            <span class="badge bg-warning text-dark" title="Total spawns: @entity.GetTotalSpawnCount()">@entity.GetTotalSpawnCount()</span>
                                            <button class="btn btn-warning" style="padding: 2px 6px; font-size: 0.7rem;" @onclick="() => ClearRegionSpawns(entity)" @onclick:stopPropagation="true" title="Clear All Spawns">
                                                <span class="bi bi-arrow-clockwise"></span>
                                            </button>
                                        }
                                    </div>
                                </div>
                                
                                @if (isSelected && entity != null)
                                {
                                    <div class="spawn-controls">
                                        <!-- 6 Frequency Buttons in 2x3 Grid -->
                                        <div class="row g-2 mb-2">
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(entity, Frequency.Water)" @onclick:stopPropagation="true" title="Water (@((Settings.WaterChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-droplet-fill frequency-icon frequency-icon-water"></i>@entity.WaterSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(entity, Frequency.Weather)" @onclick:stopPropagation="true" title="Weather (@((Settings.WeatherChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-cloud-lightning-rain-fill frequency-icon frequency-icon-weather"></i>@entity.WeatherSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-primary w-100" style="border: 2px solid;" @onclick="() => OpenCategoryModal(entity, Frequency.Timed)" @onclick:stopPropagation="true" title="Timed (@((Settings.TimedChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-clock-fill frequency-icon frequency-icon-timed"></i>@entity.TimedSpawns.Count
                                                </button>
                                            </div>
                                        </div>
                                        <div class="row g-2 mb-2">
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-secondary w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(entity, Frequency.Common)" @onclick:stopPropagation="true" title="Common (@((Settings.CommonChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-people-fill frequency-icon frequency-icon-common"></i>@entity.CommonSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-success w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(entity, Frequency.UnCommon)" @onclick:stopPropagation="true" title="Uncommon (@((Settings.UnCommonChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-person-fill frequency-icon frequency-icon-uncommon"></i>@entity.UncommonSpawns.Count
                                                </button>
                                            </div>
                                            <div class="col-4">
                                                <button class="btn btn-sm btn-danger w-100" style="border: 2px solid white; color: white;" @onclick="() => OpenCategoryModal(entity, Frequency.Rare)" @onclick:stopPropagation="true" title="Rare (@((Settings.RareChance * 100).ToString("0"))% chance)">
                                                    <i class="bi bi-star-fill frequency-icon frequency-icon-rare"></i>@entity.RareSpawns.Count
                                                </button>
                                            </div>
                                        </div>

                                        <!-- Trigger Dropdowns -->
                                        <div class="row g-2 mb-1">
                                            <div class="col-6">
                                                <label class="form-label mb-1 small text-center d-block">Weather Trigger</label>
                                                <select class="form-select form-select-sm" 
                                                        @bind="entity.WeatherSpawn" 
                                                        @bind:after="() => SaveCurrentRegion(entity)"
                                                        @onclick:stopPropagation="true"
                                                        disabled="@(entity.WeatherSpawns.Count == 0)">
                                                    @if (entity.WeatherSpawns.Count == 0)
                                                    {
                                                        <option value="@WeatherTypes.None">None</option>
                                                    }
                                                    else
                                                    {
                                                        @foreach (var weather in Enum.GetValues<WeatherTypes>().Where(w => w != WeatherTypes.None))
                                                        {
                                                            <option value="@weather">@weather.ToString()</option>
                                                        }
                                                    }
                                                </select>
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label mb-1 small text-center d-block">Timed Trigger</label>
                                                <select class="form-select form-select-sm"
                                                        @bind="entity.TimedSpawn" 
                                                        @bind:after="() => SaveCurrentRegion(entity)"
                                                        @onclick:stopPropagation="true"
                                                        disabled="@(entity.TimedSpawns.Count == 0)">
                                                    @if (entity.TimedSpawns.Count == 0)
                                                    {
                                                        <option value="@TimeNames.None">None</option>
                                                    }
                                                    else
                                                    {
                                                        @foreach (var time in Enum.GetValues<TimeNames>().Where(t => t != TimeNames.None))
                                                        {
                                                            <option value="@time">@time.ToString().Replace("_", " ")</option>
                                                        }
                                                    }
                                                </select>
                                            </div>
                                        </div>

                                        <!-- Footer Message -->
                                        @if (entity.WeatherSpawns.Count == 0 || entity.TimedSpawns.Count == 0)
                                        {
                                            <div class="row g-2 mb-2">
                                                <div class="col-12">
                                                    <small class="text-muted fst-italic">* Add Spawn to Open Triggers</small>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div class="text-center text-muted py-3">
                            <small>No regions loaded for this map</small>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

<SpawnCategoryModal IsVisible="@showModal"
                    CategoryName="@GetFrequencyName()"
                    SpawnTypeName="Spawns"
                    SourceListName="Bestiary"
                    CurrentSpawns="@currentCategorySpawns"
                    SourceList="@(BestiaryListUtility.BestiaryNameList ?? new List<string>())"
                    OnClose="@CloseModal"
                    OnSave="@SaveModal" />

@code {
    private string imageSrc = "";
    private string imageDim = "Loading...";
    private double panX = 0;
    private double panY = 0;
    private int mouseWorldX = 0;
    private int mouseWorldY = 0;
    
    private bool isPanning = false;
    
    private int imgWidth = 0;
    private int imgHeight = 0;
    
    private ElementReference mapContainerRef;
    
    // Zoom level (1.0 = actual size, 2.0 = 2x zoomed in)
    private double zoomLevel = 1.0;
    
    // Store last position AND zoom for each map (static so it persists across component instances)
    private static Dictionary<int, (double panX, double panY, double zoom)> mapPositions = new();
    
    // Track which map we're currently viewing
    private int currentMapTracked = 0;
    
    // Mini map component reference
    private MiniMapComponent? miniMapRef;

    // Region selection
    private RegionInfo? selectedRegion = null;

    // Region search index (1-based position in sorted list)
    private int? regionSearchIndex = null;
    
    // Modal state
    private bool showModal = false;
    private RegionSpawnEntity? currentEntity = null;
    private List<string> currentCategorySpawns = new();
    private Frequency currentFrequency = Frequency.Common;
    
    protected override void OnInitialized()
    {
        imageSrc = Utility.GetMapImagePath();

        if (string.IsNullOrEmpty(imageSrc))
        {
            // If no map image available, leave empty - GetMapImagePath logs the error
            Logger.Warning("No map image available for current map");
        }

        if (Utility.SESSION != null)
        {
            currentMapTracked = Utility.SESSION.Current_Map;
        }

        ViewService.OnViewChanged += OnViewChanged;
    }

    private void OnViewChanged()
    {
        // Save current position AND zoom for the OLD map (the one we're leaving)
        if (imgWidth > 0)
        {
            mapPositions[currentMapTracked] = (panX, panY, zoomLevel);
            Logger.Info($"Saved position and zoom for map {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
        }

        // Update to track the NEW map
        if (Utility.SESSION != null)
        {
            currentMapTracked = Utility.SESSION.Current_Map;
            Logger.Info($"Switching to map: {currentMapTracked}");
        }

        // Restore position AND zoom for the NEW map IMMEDIATELY so rendering is correct from the start
        if (mapPositions.TryGetValue(currentMapTracked, out var savedPos))
        {
            panX = savedPos.panX;
            panY = savedPos.panY;
            zoomLevel = savedPos.zoom;
            Logger.Info($"Pre-loaded position and zoom for map {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
        }
        else
        {
            panX = 0;
            panY = 0;
            zoomLevel = 1.0; // Default to 1x zoom for new maps
            Logger.Info($"New map {currentMapTracked}, defaulting to (0, 0) @ 1x zoom");
        }

        imageSrc = Utility.GetMapImagePath();
        selectedRegion = null;
        mouseWorldX = 0;
        mouseWorldY = 0;
        imgWidth = 0;
        imgHeight = 0;
        imageDim = "Loading...";
        InvokeAsync(StateHasChanged);
    }
    
    private async Task OnImageLoaded()
    {
        try
        {
            var result = await JS.InvokeAsync<string>("eval", @"
                (function() {
                    const img = document.getElementById('regionMapImg');
                    if (img && img.naturalWidth > 0) {
                        return img.naturalWidth + ',' + img.naturalHeight;
                    }
                    return '';
                })()
            ");
            
            if (!string.IsNullOrEmpty(result))
            {
                var parts = result.Split(',');
                if (int.TryParse(parts[0], out int w) && int.TryParse(parts[1], out int h))
                {
                    imgWidth = w;
                    imgHeight = h;
                    imageDim = $"{w}x{h}";
                    
                    // Restore saved position AND zoom for THIS map
                    if (mapPositions.TryGetValue(currentMapTracked, out var savedPos))
                    {
                        panX = savedPos.panX;
                        panY = savedPos.panY;
                        zoomLevel = savedPos.zoom;
                        Logger.Info($"Restored position and zoom for map {currentMapTracked}: ({panX:F0}, {panY:F0}) @ {zoomLevel}x");
                    }
                    else
                    {
                        panX = 0;
                        panY = 0;
                        zoomLevel = 1.0;
                        Logger.Info($"First visit to map {currentMapTracked}, starting at (0, 0) @ 1x");
                    }

                    // Initialize map module with custom canvas/img IDs
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.init({w}, {h}, 'regionMapCanvas', 'regionMapImg')");

                    // Set zoom level BEFORE any coordinate calculations (BoxSpawn pattern)
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.setZoomLevel({zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)})");

                    // Apply pan position AFTER zoom is set, BEFORE minimap init
                    await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

                    // Initialize the mini map component AFTER pan is applied, passing current values
                    if (miniMapRef != null)
                    {
                        await miniMapRef.InitializeAsync(panX, panY, zoomLevel);
                    }

                    await RenderRegions();

                    // Re-apply XML spawners if toggle is ON
                    if (ViewService.ShowXMLSpawners)
                    {
                        var xmlSpawners = SpawnerListUtility.GetSpawnersForMap(ViewService.CurrentMapId);
                        if (xmlSpawners.Count > 0)
                        {
                            var options = new System.Text.Json.JsonSerializerOptions 
                            { 
                                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
                                WriteIndented = false 
                            };
                            var json = System.Text.Json.JsonSerializer.Serialize(xmlSpawners, options);
                            await JS.InvokeVoidAsync("eval", $"window.mapModule.showXMLSpawners({json})");
                            Logger.Info($"Re-applied XML spawners for {ViewService.CurrentMapId}: {xmlSpawners.Count} spawners");
                        }
                    }

                    // Re-apply server spawns if toggle is ON
                    if (ViewService.ShowServerSpawns && MapDisplayUtility.HasSpawnData)
                    {
                        var spawnData = MapDisplayUtility.GetSpawnDataForMap(ViewService.CurrentMapId);
                        if (spawnData.Count > 0)
                        {
                            var options = new System.Text.Json.JsonSerializerOptions 
                            { 
                                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
                                WriteIndented = false 
                            };
                            var json = System.Text.Json.JsonSerializer.Serialize(spawnData, options);
                            await JS.InvokeVoidAsync("eval", $"window.mapModule.showServerSpawns({json})");
                            Logger.Info($"Re-applied server spawns for {ViewService.CurrentMapId}: {spawnData.Count} spawn points");
                        }
                    }

                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.Error("Image load error", ex);
            imageDim = "Error loading image";
        }
    }

    private async Task RenderRegions()
    {
        try
        {
            var regions = GetRegionsForCurrentMap();
            Logger.Info($"RenderRegions called for map {ViewService.CurrentMapId}: Found {regions.Count} regions");

            if (regions.Count == 0)
            {
                Logger.Warning($"No regions found for map {ViewService.CurrentMapId}");
                return;
            }

            // Sort regions by name to match the list order, then assign indices
            var sortedRegions = regions.OrderBy(r => r.Name).ToList();
            var screenRegions = sortedRegions.Select((r, index) => new
            {
                name = r.Name,
                listIndex = index + 1, // 1-based index to match UI
                rectangles = r.Rectangles.Select(rect => new
                {
                    x = rect.X,
                    y = rect.Y,
                    width = rect.Width,
                    height = rect.Height
                }).ToList()
            }).ToList();

            var selectedName = selectedRegion?.Name ?? "";
            var hoveredName = "";

            Logger.Info($"Serializing {screenRegions.Count} regions, selected='{selectedName}'");

            var options = new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = false 
            };
            var regionsJson = JsonSerializer.Serialize(screenRegions, options);
            var selectedNameJson = JsonSerializer.Serialize(selectedName);
            var hoveredNameJson = JsonSerializer.Serialize(hoveredName);

            Logger.Info($"Calling JavaScript showRegions with JSON (length: {regionsJson.Length})");
            await JS.InvokeVoidAsync("eval", $"window.mapModule.showRegions({regionsJson}, {selectedNameJson}, {hoveredNameJson})" );
            Logger.Info("RenderRegions completed successfully");
        }
        catch (Exception ex)
        {
            Logger.Error("Error rendering regions", ex);
        }
    }
    
    // ===================== MAP CONTROLS =====================
    
    private async Task ToggleZoom()
    {
        // Calculate the current center of the viewport in world coordinates
        // This is what we want to keep centered after zoom changes
        double centerWorldX = (-panX / zoomLevel) + (800.0 / 2.0 / zoomLevel);
        double centerWorldY = (-panY / zoomLevel) + (600.0 / 2.0 / zoomLevel);

        Logger.Info($"Current center before zoom: world ({centerWorldX:F0}, {centerWorldY:F0}) at {zoomLevel}x");

        // Toggle between 1x (actual size) and 2x (zoomed in)
        double oldZoom = zoomLevel;
        zoomLevel = zoomLevel == 2.0 ? 1.0 : 2.0;

        // Recalculate pan to keep the same world position centered
        // Formula: panX = -(centerWorldX * newZoom) + (viewport_width / 2)
        panX = -(centerWorldX * zoomLevel) + 400; // 800/2
        panY = -(centerWorldY * zoomLevel) + 300; // 600/2

        Logger.Info($"New center after zoom: world ({centerWorldX:F0}, {centerWorldY:F0}) at {zoomLevel}x, pan=({panX:F0}, {panY:F0})");

        // Update JavaScript zoom level immediately
        await JS.InvokeVoidAsync("eval", $"window.mapModule.setZoomLevel({zoomLevel.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)})");

        // Apply the new pan position
        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

        // Save the new zoom level and position for current map
        mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

        // Redraw regions to ensure they're correctly positioned
        await RenderRegions();

        // Update mini-map viewport with new zoom
        if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);

        StateHasChanged();
    }

    private async Task ResetView()
    {
        panX = 0;
        panY = 0;
        zoomLevel = 1.0;
        await JS.InvokeVoidAsync("eval", $"window.mapModule.setZoomLevel(1.0)");
        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan(0, 0)");
        if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);
        await RenderRegions();
        StateHasChanged();
    }

    // ===================== MOUSE EVENTS =====================
    
    private async Task OnMouseDown(MouseEventArgs e)
    {
        if (e.Button == 0) // Left-click for region selection
        {
            var coords = await JS.InvokeAsync<int[]>("eval", $"window.mapModule.getWorldCoordinates({e.OffsetX}, {e.OffsetY})");
            if (coords.Length == 2)
            {
                mouseWorldX = coords[0];
                mouseWorldY = coords[1];

                var clickedRegion = RegionListUtility.FindRegionAt(ViewService.CurrentMapId, mouseWorldX, mouseWorldY);
                if (clickedRegion != null)
                {
                    // Find which specific area was clicked
                    var clickedAreaIndex = RegionListUtility.FindAreaIndexAt(clickedRegion, mouseWorldX, mouseWorldY);
                    await SelectRegion(clickedRegion, clickedAreaIndex);
                }
            }
        }
        else if (e.Button == 2) // Right-click for panning
        {
            isPanning = true;
            await JS.InvokeVoidAsync("eval", $"window.mapModule.startPanning({e.OffsetX}, {e.OffsetY})");
        }
    }
    
    private async Task OnMouseMove(MouseEventArgs e)
    {
        var coords = await JS.InvokeAsync<int[]>("eval", $"window.mapModule.getWorldCoordinates({e.OffsetX}, {e.OffsetY})");
        if (coords.Length == 2)
        {
            mouseWorldX = coords[0];
            mouseWorldY = coords[1];
            StateHasChanged();

            // Update XML spawner hover (for dwell-based tooltip, like server spawns)
            if (ViewService.ShowXMLSpawners)
            {
                await JS.InvokeVoidAsync("eval", $"window.mapModule.updateXmlSpawnerHover({e.OffsetX}, {e.OffsetY})");
            }

            // Update server spawn hover (for dwell-based tooltip)
            if (ViewService.ShowServerSpawns)
            {
                await JS.InvokeVoidAsync("eval", $"window.mapModule.updateServerSpawnHover({e.OffsetX}, {e.OffsetY})");
            }

            // Detect hovered region and area for visual feedback
            var hoveredRegion = RegionListUtility.FindRegionAt(ViewService.CurrentMapId, mouseWorldX, mouseWorldY);
            if (hoveredRegion != null)
            {
                var areaIndex = RegionListUtility.FindAreaIndexAt(hoveredRegion, mouseWorldX, mouseWorldY);
                await JS.InvokeVoidAsync("eval", $"window.mapModule.setHoveredRegionArea('{hoveredRegion.Name.Replace("'", "\\'")}', {areaIndex})");
            }
            else
            {
                await JS.InvokeVoidAsync("eval", "window.mapModule.setHoveredRegionArea(null, -1)");
            }
        }

        if (isPanning)
        {
            await JS.InvokeVoidAsync("eval", $"window.mapModule.updatePanning({e.OffsetX}, {e.OffsetY})");

            // Get updated pan position
            var panCoords = await JS.InvokeAsync<double[]>("eval", "window.mapModule.getPan()");
            if (panCoords.Length == 2)
            {
                panX = panCoords[0];
                panY = panCoords[1];
            }

            if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        if (e.Button == 2)
        {
            isPanning = false;
        }
    }
    
    private async Task OnMouseLeave(MouseEventArgs e)
    {
        isPanning = false;
        await JS.InvokeVoidAsync("eval", "window.mapModule.setHoveredRegionArea(null, -1)");

        // Clear XML spawner hover when mouse leaves
        if (ViewService.ShowXMLSpawners)
        {
            await JS.InvokeVoidAsync("eval", "window.mapModule.clearXmlSpawnerHover()");
        }

        // Clear server spawn hover when mouse leaves
        if (ViewService.ShowServerSpawns)
        {
            await JS.InvokeVoidAsync("eval", "window.mapModule.clearServerSpawnHover()");
        }
    }

    private async Task HandleMiniMapClick((double panX, double panY) newPosition)
    {
        panX = newPosition.panX;
        panY = newPosition.panY;

        // Save the new position for the current map (preserve zoom)
        mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

        await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");

        // Update the mini map viewport
        if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);

        await RenderRegions();
        StateHasChanged();
    }

    // ===================== KEYBOARD EVENTS =====================
    
    private void OnMapMouseEnter(MouseEventArgs e)
    {
        mapContainerRef.FocusAsync();
    }
    
    // Key panning state tracking
    private bool isKeyPanning = false;
    private System.Threading.Timer? keyPanTimer;

    private async Task StartKeyPanTracking()
    {
        if (isKeyPanning) return;
        isKeyPanning = true;

        // Start a timer that syncs pan position while keys are held
        keyPanTimer = new System.Threading.Timer(async _ =>
        {
            if (!isKeyPanning) return;

            try
            {
                await InvokeAsync(async () =>
                {
                    var result = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.mapModule.getPanPosition())");
                    if (!string.IsNullOrEmpty(result))
                    {
                        var pos = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, double>>(result);
                        if (pos != null)
                        {
                            panX = pos["x"];
                            panY = pos["y"];
                            if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);
                            StateHasChanged();
                        }
                    }
                });
            }
            catch { }
        }, null, 0, 50); // Update every 50ms (~20fps)
    }

    private void StopKeyPanTracking()
    {
        isKeyPanning = false;
        keyPanTimer?.Dispose();
        keyPanTimer = null;
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        // Check if it's a panning key (WASD or arrows)
        var key = e.Key.ToLower();
        if (key == "w" || key == "a" || key == "s" || key == "d" ||
            key == "arrowup" || key == "arrowdown" || key == "arrowleft" || key == "arrowright")
        {
            // Add key to active set and start smooth animation
            await JS.InvokeVoidAsync("eval", $"window.mapModule.addKey('{key}')");

            // Start tracking pan position for minimap updates
            await StartKeyPanTracking();
        }
    }

    private async Task OnKeyUp(KeyboardEventArgs e)
    {
        // Remove key from active set
        var key = e.Key.ToLower();
        await JS.InvokeVoidAsync("eval", $"window.mapModule.removeKey('{key}')");

        // Check if all keys are released
        var keysCount = await JS.InvokeAsync<int>("eval", "window.mapModule.keyStates.size");
        if (keysCount == 0)
        {
            // Stop tracking when all keys released
            StopKeyPanTracking();
        }

        // Sync pan position from JavaScript back to C#
        try
        {
            var result = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.mapModule.getPanPosition())");
            if (!string.IsNullOrEmpty(result))
            {
                var pos = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, double>>(result);
                if (pos != null)
                {
                    panX = pos["x"];
                    panY = pos["y"];

                    // Save the new position for the current map (preserve zoom)
                    mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

                    if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);
                    StateHasChanged();
                }
            }
        }
        catch { }
    }
    
    // ===================== REGION DATA =====================
    
    private List<RegionInfo> GetRegionsForCurrentMap()
    {
        return RegionListUtility.GetRegionsForMap(ViewService.CurrentMapId);
    }

    private int GetRegionCount()
    {
        return GetRegionsForCurrentMap().Count;
    }

    /// <summary>
    /// Truncates region names to max 12 characters for compact card display.
    /// Full name shown when card is selected (handled in markup).
    /// </summary>
    private string FormatRegionName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        // Max 12 characters when card is not focused
        if (name.Length > 12)
        {
            return name[..9] + "...";
        }

        return name;
    }

    private int? GetDisplayedRegionIndex()
    {
        // If no regions exist, show 0
        if (GetRegionCount() == 0)
        {
            return 0;
        }

        // If user is typing (regionSearchIndex has manual value), show that
        // Otherwise show the selected region's position in sorted list, or null
        if (regionSearchIndex.HasValue)
        {
            return regionSearchIndex;
        }

        if (selectedRegion != null)
        {
            var regions = GetRegionsForCurrentMap().OrderBy(r => r.Name).ToList();
            var index = regions.FindIndex(r => r.Name == selectedRegion.Name);
            return index >= 0 ? index + 1 : null; // 1-based
        }

        return null;
    }

    private async Task HandleRegionIndexInput(ChangeEventArgs e)
    {
        int maxCount = GetRegionCount();

        // If no regions exist, ignore input and keep at 0
        if (maxCount == 0)
        {
            regionSearchIndex = null;
            return;
        }

        // Parse the input value
        if (int.TryParse(e.Value?.ToString(), out int value))
        {
            regionSearchIndex = value;
        }
        else
        {
            regionSearchIndex = null;
        }

        // Validate and auto-jump
        if (regionSearchIndex.HasValue)
        {
            // Clamp value to valid range
            if (regionSearchIndex.Value > maxCount)
            {
                regionSearchIndex = maxCount;
                Logger.Info($"Region search index clamped to max: {maxCount}");
            }
            else if (regionSearchIndex.Value < 1)
            {
                regionSearchIndex = 1;
                Logger.Info("Region search index clamped to min: 1");
            }

            // Auto-jump to the region at this index (1-based)
            var regions = GetRegionsForCurrentMap().OrderBy(r => r.Name).ToList();
            if (regionSearchIndex.Value >= 1 && regionSearchIndex.Value <= regions.Count)
            {
                var targetRegion = regions[regionSearchIndex.Value - 1]; // Convert to 0-based
                await SelectRegion(targetRegion);
                Logger.Info($"Quick search: jumped to region #{regionSearchIndex.Value} '{targetRegion.Name}'");
            }
        }
    }

    private RegionSpawnEntity? GetRegionEntity(string regionName)
    {
        if (!Utility.RegionSpawns.TryGetValue(ViewService.CurrentMapId, out var list))
            return null;
        
        return list.FirstOrDefault(r => r.Name.Equals(regionName, StringComparison.OrdinalIgnoreCase));
    }
    
    private async Task SelectRegion(RegionInfo region, int areaIndex = 0)
    {
        selectedRegion = region;

        if (!Utility.RegionSpawns.TryGetValue(ViewService.CurrentMapId, out var list))
        {
            list = new List<RegionSpawnEntity>();
            Utility.RegionSpawns[ViewService.CurrentMapId] = list;
        }

        var existing = list.FirstOrDefault(r => r.Name.Equals(region.Name, StringComparison.OrdinalIgnoreCase));
        if (existing != null)
        {
            currentEntity = existing;
        }
        else
        {
            var nextId = list.Count > 0 ? list.Max(x => x.Id) + 1 : 1;
            currentEntity = new RegionSpawnEntity
            {
                Id = nextId,
                Name = region.Name,
                MapId = ViewService.CurrentMapId,
                RegionBounds = region.Rectangles.ToList()
            };
            list.Add(currentEntity);
        }

        // Render regions to highlight selection, then jump to clicked area
        await RenderRegions();
        await JumpToRegion(region, areaIndex);

        // Trigger UI update to expand the region card
        StateHasChanged();

        // Wait for DOM update, then scroll to the card
        await Task.Delay(150);
        await ScrollToSelectedRegion();
    }

    private async Task JumpToRegion(RegionInfo region, int areaIndex = 0)
    {
        try
        {
            // Calculate the center of the specified rectangle (or first if invalid index)
            if (region.Rectangles.Count == 0) return;

            // Clamp area index to valid range
            if (areaIndex < 0 || areaIndex >= region.Rectangles.Count)
                areaIndex = 0;

            var targetRect = region.Rectangles[areaIndex];
            double centerX = targetRect.X + (targetRect.Width / 2.0);
            double centerY = targetRect.Y + (targetRect.Height / 2.0);

            // Center the viewport on this position
            // Account for current zoom level and viewport size
            double newPanX = -(centerX * zoomLevel) + 400; // Center horizontally (800/2)
            double newPanY = -(centerY * zoomLevel) + 300; // Center vertically (600/2)

            panX = newPanX;
            panY = newPanY;

            // Save the new position for the current map (preserve zoom)
            mapPositions[currentMapTracked] = (panX, panY, zoomLevel);

            await JS.InvokeVoidAsync("eval", $"window.mapModule.applyPan({panX}, {panY})");
            if (miniMapRef != null) await miniMapRef.UpdateViewport(panX, panY, zoomLevel);

            Logger.Info($"Jumped to region '{region.Name}' area {areaIndex} at ({centerX:F0}, {centerY:F0})");
        }
        catch (Exception ex)
        {
            Logger.Error($"Error jumping to region '{region.Name}'", ex);
        }
    }

    private async Task ScrollToSelectedRegion()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", @"
                (function() {
                    const selected = document.querySelector('.spawn-item.selected');
                    if (selected) {
                        selected.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                })()
            ");
        }
        catch (Exception ex)
        {
            Logger.Error("Scroll to region error", ex);
        }
    }

    private async Task ClearRegionSpawns(RegionSpawnEntity entity)
    {
        // Clear all spawn lists but keep the region entity (regions are static server data)
        entity.WaterSpawns.Clear();
        entity.WeatherSpawns.Clear();
        entity.TimedSpawns.Clear();
        entity.CommonSpawns.Clear();
        entity.UncommonSpawns.Clear();
        entity.RareSpawns.Clear();

        // Reset triggers
        entity.WeatherSpawn = WeatherTypes.None;
        entity.TimedSpawn = TimeNames.None;

        // Mark data as dirty - spawns were cleared
        PathConstants.IsSpawnDataDirty = true;

        // Auto-save region spawn data
        Utility.SaveRegionSpawnData();
        Logger.Info($"Cleared all spawns for region '{entity.Name}' and auto-saved");

        // Update UI to reflect empty spawn counts
        StateHasChanged();
    }

    // ===================== MODAL HANDLING =====================
    
    private void OpenCategoryModal(RegionSpawnEntity entity, Frequency frequency)
    {
        currentEntity = entity;
        currentFrequency = frequency;
        
        currentCategorySpawns = frequency switch
        {
            Frequency.Water => new List<string>(entity.WaterSpawns),
            Frequency.Weather => new List<string>(entity.WeatherSpawns),
            Frequency.Timed => new List<string>(entity.TimedSpawns),
            Frequency.Common => new List<string>(entity.CommonSpawns),
            Frequency.UnCommon => new List<string>(entity.UncommonSpawns),
            Frequency.Rare => new List<string>(entity.RareSpawns),
            _ => new List<string>()
        };
        
        showModal = true;
        StateHasChanged();
    }
    
    private void CloseModal()
    {
        showModal = false;
        StateHasChanged();
    }
    
    private void SaveModal()
    {
        if (currentEntity == null) return;
        
        var updatedList = new List<string>(currentCategorySpawns);
        
        switch (currentFrequency)
        {
            case Frequency.Water:
                currentEntity.WaterSpawns = updatedList;
                break;
            case Frequency.Weather:
                currentEntity.WeatherSpawns = updatedList;
                if (updatedList.Count > 0 && currentEntity.WeatherSpawn == WeatherTypes.None)
                {
                    currentEntity.WeatherSpawn = WeatherTypes.Rain;
                }
                if (updatedList.Count == 0)
                {
                    currentEntity.WeatherSpawn = WeatherTypes.None;
                }
                break;
            case Frequency.Timed:
                currentEntity.TimedSpawns = updatedList;
                if (updatedList.Count > 0 && currentEntity.TimedSpawn == TimeNames.None)
                {
                    currentEntity.TimedSpawn = TimeNames.Witching_Hour;
                }
                if (updatedList.Count == 0)
                {
                    currentEntity.TimedSpawn = TimeNames.None;
                }
                break;
            case Frequency.Common:
                currentEntity.CommonSpawns = updatedList;
                break;
            case Frequency.UnCommon:
                currentEntity.UncommonSpawns = updatedList;
                break;
            case Frequency.Rare:
                currentEntity.RareSpawns = updatedList;
                break;
        }

        // Mark data as dirty - spawn entries changed
        PathConstants.IsSpawnDataDirty = true;

        SaveCurrentRegion(currentEntity);
        CloseModal();
        StateHasChanged();
    }
    
    private void SaveCurrentRegion(RegionSpawnEntity entity)
    {
        try
        {
            Utility.SaveRegionSpawnData();
            Logger.Info($"Auto-saved region spawn data for {entity.Name}");
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to save region spawn data", ex);
            ToastService.ShowError("Failed to save region spawn data");
        }
    }
    
    private string GetFrequencyName()
    {
        return currentFrequency switch
        {
            Frequency.Water => "Water",
            Frequency.Weather => "Weather",
            Frequency.Timed => "Timed",
            Frequency.Common => "Common",
            Frequency.UnCommon => "Uncommon",
            Frequency.Rare => "Rare",
            _ => "Spawns"
        };
    }
    
    private int GetTotalRegionSpawnCount()
    {
        int total = 0;
        var regions = GetRegionsForCurrentMap();
        foreach (var region in regions)
        {
            var entity = GetRegionEntity(region.Name);
            if (entity != null)
            {
                total += entity.GetTotalSpawnCount();
            }
        }
        return total;
    }

    public void Dispose()
    {
        ViewService.OnViewChanged -= OnViewChanged;
        keyPanTimer?.Dispose();
    }
}
